# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License.

import re
from typing import List, Optional, Union

from generator import model

PARTS_RE = re.compile(r"(([a-z0-9])([A-Z]))")


def lines_to_doc_comments(lines: List[str]) -> List[str]:
    if not lines:
        return []
    return (
        ["/// <summary>"]
        + [f"/// {line}" for line in lines if not line.startswith("@")]
        + ["/// </summary>"]
    )


def get_parts(name: str) -> List[str]:
    name = name.replace("_", " ")
    return PARTS_RE.sub(r"\2 \3", name).split()


def to_upper_camel_case(name: str) -> str:
    return "".join([c.capitalize() for c in get_parts(name)])


def file_header() -> List[str]:
    return [
        "// Copyright (c) Microsoft Corporation. All rights reserved.",
        "// Licensed under the MIT License.",
        "// ",
        "// THIS FILE IS AUTOGENERATED, DO NOT MODIFY IT",
        "",
    ]


def namespace_wrapper(
    namespace: str, imports: List[str], lines: List[str]
) -> List[str]:
    indent = " " * 4
    return (
        file_header()
        + imports
        + [""]
        + ["namespace " + namespace + " {"]
        + [(f"{indent}{line}" if line else line) for line in lines]
        + ["}", ""]
    )


def get_doc(doc: Optional[str]) -> str:
    if doc:
        return lines_to_doc_comments(doc.splitlines(keepends=False))
    return []


def class_wrapper(
    type_def: Union[model.Structure, model.Notification, model.Request],
    inner: List[str],
    derived: Optional[str] = None,
) -> List[str]:
    if hasattr(type_def, "name"):
        name = type_def.name
        if name == "Command":
            name = "CommandAction"
    else:
        raise ValueError(f"Unknown type: {type_def}")

    lines = (
        get_doc(type_def.documentation)
        + generate_extras(type_def)
        + [
            "[DataContract]",
            f"public class {name}: {derived}" if derived else f"public class {name}",
            "{",
        ]
    )
    lines += indent_lines(inner)
    lines += ["}", ""]
    return lines


def interface_wrapper(
    type_def: Union[model.Structure, model.Notification, model.Request],
    inner: List[str],
    derived: Optional[str] = None,
) -> List[str]:
    if hasattr(type_def, "name"):
        name = type_def.name
    else:
        raise ValueError(f"Unknown type: {type_def}")

    lines = (
        get_doc(type_def.documentation)
        + generate_extras(type_def)
        + [
            (
                f"public interface {name}: {derived}"
                if derived
                else f"public interface {name}"
            ),
            "{",
        ]
    )
    lines += indent_lines(inner)
    lines += ["}", ""]
    return lines


def property_wrapper(prop_def: model.Property, content: List[str]) -> List[str]:
    lines = (get_doc(prop_def.documentation) + generate_extras(prop_def) + content,)
    lines += indent_lines(content)
    return lines


def indent_lines(lines: List[str], indent: str = " " * 4) -> List[str]:
    return [(f"{indent}{line}" if line else line) for line in lines]


def cleanup_str(text: str) -> str:
    return text.replace("\r", "").replace("\n", "")


def generate_extras(
    type_def: Union[
        model.Enum, model.EnumItem, model.Property, model.TypeAlias, model.Structure
    ]
) -> List[str]:
    extras = []
    if type_def.deprecated:
        extras += [f'[Obsolete("{cleanup_str(type_def.deprecated)}")]']
    if type_def.proposed:
        extras += [f"[Proposed]"]
    if type_def.since:
        extras += [f'[Since("{cleanup_str(type_def.since)}")]']

    return extras


def get_usings(types: List[str]) -> List[str]:
    usings = []

    for t in ["DataMember", "DataContract"]:
        if t in types:
            usings.append("using System.Runtime.Serialization;")

    for t in ["JsonConverter", "JsonConstructor", "JsonProperty", "NullValueHandling"]:
        if t in types:
            usings.append("using Newtonsoft.Json;")

    for t in ["JToken", "JObject", "JArray"]:
        if t in types:
            usings.append("using Newtonsoft.Json.Linq;")

    return list(set(usings))
